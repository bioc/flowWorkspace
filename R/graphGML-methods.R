#' get nodes from {graphGML} object
#'
#' @param x \code{graphGML}
#' @param y \code{character} node index. When \code{missing}, return all the nodes
#' @param order \code{character} specifying the order of nodes. options are "default", "bfs", "dfs", "tsort"
#' @param only.names \code{logical} specifiying whether user wants to get the entire \code{nodeData} or just the name of the population node
#' @return It returns the node names and population names by default. Or return the entire nodeData associated with each node.   
#' @export
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' getNodes(g)
#' getNodes(gt, only.names = FALSE)
#' } 
setMethod("getNodes", signature = c("graphGML"),
          definition = function(x, y
                                  , order = c("default", "bfs", "dfs", "tsort")
                                  , only.names = TRUE) {
  
  if (missing(y)){
    res <- nodeData(x)
    order <- match.arg(order)
    if(order != "default"){
      nodeIds <- eval(substitute(f1(x),list(f1=as.symbol(order))))
      if(order == "dfs")
        nodeIds <- nodeIds$discovered
      res <- res[nodeIds]
    }
  }else
  {
    res <- nodeData(x, y)
  }
  if(only.names){
    res <- sapply(res,`[[`,"popName")
  }
  if(length(res) == 1 && class(res) == "list")
      res <- res[[1]]
   res
})

#' get children nodes
#'
#' @param obj \code{graphGML}
#' @param y \code{character} parent node path  
#' @export 
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' getChildren(g, "GateSet_694130")
#' getParent(g, "GateSet_694130") 
#' }
#' @importClassesFrom methods character ANY data.frame environment list logical matrix missing numeric oldClass
setMethod("getChildren", signature = c("graphGML", "character"),
          definition = function(obj, y) {
  edges(obj, y)[[1]]
})

#' get parent nodes
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} child node path
#' 
#' @export
setMethod("getParent", signature = c("graphGML", "character"),
          definition = function(obj, y) {

   inEdges(y, obj)[[1]]
  
})

#' get gate from the node
#' 
#' @param obj \code{graphGML}
#' @param y \code{character} node path
#' @export 
setMethod("getGate", signature = c("graphGML", "character"),
          definition = function(obj, y) {

          nodeData(obj, y)[["gateInfo"]]
})


#' show method for graphGML
#' 
#' show method for graphGML
#' 
#' @param object \code{graphGML}
#' @export 
#' @importFrom methods show
setMethod("show", signature = c("graphGML"),
          definition = function(object) {
  cat("--- Gating hieararchy parsed from GatingML: ")
  
  cat("\n")
  cat("\twith ", length(object@nodes), " populations defined\n")
})


#' plot the population tree stored in graphGML.
#' 
#' The node with dotted order represents the population that has tailored gates (sample-specific gates) defined.
#'  
#' @param x a graphNEL generated by constructTree function
#' @param y not used
#' @param label specifies what to be dispaled as node label. Can be either 'popName' (population name parsed from GateSets) or 'gateName'(the name of the actual gate associated with each node)
#' @export
#' @importFrom graph nodeData nodes<- nodeRenderInfo<-
#' @importFrom Rgraphviz renderGraph layoutGraph
#' @examples 
#' \dontrun{
#' xmlfile <- system.file("extdata/cytotrol_tcell_cytobank.xml", package = "flowWorkspace")
#' g <- read.gatingML.cytobank(xmlfile)
#' plot(g)
#'  
#' }

setMethod("plot", signature = c(x = "graphGML", y = "missing"), definition = function(x, y = "missing", label = c("popName", "gateName")){
  label <- match.arg(label, c("popName", "gateName"))
  if(label == "popName")
    nodeLabel  <- sapply(nodeData(x), `[[`, "popName")
  else
    nodeLabel  <- sapply(nodeData(x), function(i)i[["gateInfo"]][["gateName"]])
  
  
  #annotate the node with tailor gate info
  nTailoredGate <- sapply(nodeData(x), function(i)length(i[["gateInfo"]][["tailored_gate"]]))
  
  nAttrs <- list()
  
  nAttrs$label <- nodeLabel
  
  nAttrs$lty <- sapply(nTailoredGate
                       ,function(i)
                       {
                         ifelse(i>0,"dotted","solid")
                       })
  
  nodeRenderInfo(x) <- nAttrs
  lay <- layoutGraph(x
                     ,attrs=list(graph=list(rankdir="LR",page=c(8.5,11))
                                 ,node=list(fixedsize=FALSE
                                            ,fontsize = 12
                                            ,shape="ellipse"
                                 )
                     )
  )
  renderGraph(lay)
  
})

#' Apply the gatingML graph to a GatingSet
#' 
#' It applies the gates to the GatingSet based on the population tree described in graphGML.
#' 
#' @param x graphGML
#' @param y GatingSet
#' @param ... other arguments
#' @return 
#' Nothing. As the side effect, gates generated by gating methods are saved in \code{GatingSet}. 
#' @export
#' @rdname gating-methods
setGeneric("gating", function(x, y, ...) standardGeneric("gating"))

#' @aliases 
#' gating,graphGML,GatingSet-method
#' @rdname gating-methods
setMethod("gating", signature = c("graphGML", "GatingSet"), function(x, y, ...){
  gating.graphGML(x, y, ...)
})

#' @importFrom RBGL tsort
gating.graphGML <- function(gt, gs, ...) {
  
  
  
  gt_nodes <- tsort(gt)
  for (nodeID in gt_nodes) {
    
    # get parent node to gate
    gt_node <- getNodes(gt, nodeID, only.names = F)
    popName <- gt_node[["popName"]]
    parentID <- getParent(gt, nodeID)
    
    if(length(parentID) == 0)
      parent <- "root"
    else
      parent <- getNodes(gt, parentID, only.names = F)[["popName"]]
    
    #TODO: rename the node name with path in order to match against gs    
#     parentInd <- match(parent, getNodes(gs[[1]], showHidden = TRUE))
#     if (is.na(parentInd)) 
#       stop("parent node '", parent, "' not gated yet!")
  
    this_gate <- gt_node[["gateInfo"]][["gate"]]
    this_gate <- sapply(sampleNames(gs), function(i)this_gate)
    #update gates that are tailored for specific samples
    tailor_gate <- gt_node[["gateInfo"]][["tailored_gate"]]
    if(length(tailor_gate) >0){
          this_gate[names(tailor_gate)] <- tailor_gate
    }
    
    
    message(popName)
    
    add(gs, this_gate, parent = parent, name = popName)
    
  } 
  recompute(gs)
}

#' Extract compensation from graphGML object.
#' @param x graphGML
#' @return compensation object or "FCS" when compensation comes from FCS keywords
#' @export
setMethod("getCompensationMatrices", signature = "graphGML", definition = function(x){
  x@graphData[["compensation"]]
  
})

#' Extract transformations from graphGML object.
#' @param x graphGML
#' @return transformList object
#' @importFrom flowCore transformList eval parameters colnames
#' @export
setMethod("getTransformations", signature = c(x = "graphGML"), function(x){
  
  x@graphData[["transformations"]]
  
  
})

#' compensate a flowSet based on the compensation information stored in graphGML object
#' 
#' 
#' @param x flowSet
#' @param spillover graphGML
#' @param ... unused.
#' @return compensated flowSet
#' @importFrom flowCore compensate
#' @export
setMethod("compensate", signature = c("flowSet", "graphGML"), function(x, spillover, ...){
  
  comp <- getCompensationMatrices(spillover)
  
  if(comp == "FCS"){
    mat <- compact(spillover(x[[1, use.exprs = FALSE]]))[[1]]
    comp <- compensation(mat)
  }
  compensate(x, comp)
})